// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name OlivePayLibrary
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CoreLocation
import CoreTelephony
import Darwin
import Foundation
import MessageUI
@_exported import OlivePayLibrary
import Security
import Swift
import SystemConfiguration
import UIKit
import _Concurrency
import _StringProcessing
@_inheritsConvenienceInitializers final public class CBCMAC : OlivePayLibrary.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: OlivePayLibrary.BlockModeOption { get }
  func worker(blockSize: Swift.Int, cipherOperation: @escaping OlivePayLibrary.CipherOperationOnBlock) throws -> OlivePayLibrary.CipherModeWorker
}
extension UIKit.UIColor {
  open class var axisbankBrandColor: UIKit.UIColor {
    get
  }
}
public enum PKCS7 {
}
public class CMAC : OlivePayLibrary.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: OlivePayLibrary.CMAC.Error, b: OlivePayLibrary.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: OlivePayLibrary.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public enum PKCS5 {
}
@_hasMissingDesignatedInitializers final public class Checksum {
  @objc deinit
}
extension OlivePayLibrary.Checksum {
  public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16
}
public struct OFB : OlivePayLibrary.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: OlivePayLibrary.OFB.Error, b: OlivePayLibrary.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: OlivePayLibrary.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping OlivePayLibrary.CipherOperationOnBlock) throws -> OlivePayLibrary.CipherModeWorker
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension OlivePayLibrary.Updatable {
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish() throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class OliveUpiManager : ObjectiveC.NSObject {
  public static func getNextRandomIndex() -> Swift.Int
  public static func initiateSDKWithSkipBind(sdkHandshake: Any?, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func initiateSDK(sdkHandshake: Any?, view: UIKit.UIViewController, delegate: MessageUI.MFMessageComposeViewControllerDelegate, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  public static func getServerToken(serverToken: Any?, callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func clearCache()
  public static func sendSkipBindReqst(callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func sendMobileBindReqst(callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func listKeys(callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func fetchListBanks(callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func fetchAccountsiin(iin: Swift.String, accountType: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func fetchMyAccounts(callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func updateVPA(vpa: Swift.String, account: Any?, callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func checkBalance(account: Any?, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func changeMpin(bankid: Swift.String, account: Any?, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func restUPIPin(bankId: Swift.String, account: Any?, type: Swift.String, cardNo: Swift.String, exp: Swift.String, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func tranHistory(fromDate: Swift.String, toDate: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func raiseQuery(txnid: Swift.String, refid: Swift.String, amount: Swift.String, query: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func queryList(callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func pendingNotifications(callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func getVpasFromContact(mobile: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func initiateCollect(beneaccount: Any?, remittervpa: Any?, amount: Swift.String, remarks: Swift.String, merchantvpa: Swift.String, merchantid: Swift.String, submerchantid: Swift.String, merchantchannelid: Swift.String, trantype: Swift.String, expiry: Swift.String, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func initiatePay(account: Any?, benevpa: Any?, paymentInput: Any?, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func collectApprove(account: Any?, PendingReq: Any?, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func parseQRString(code: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func accountRemove(account: Any?, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func removeVpa(vpa: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func listvpa(callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func saveBeneVpa(bene: Any?, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func activateAccount(iin: Swift.String, account: Any?, cardNo: Swift.String, exp: Swift.String, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func checkvpa(vpa: Swift.String, payerInfo: Any?, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func collectReject(pendingReqVo: Any?, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func collectBlockUnblock(vpa: Swift.String, block: Swift.String, reason: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func collectBlocklist(callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func getRegisteredMobileNumber() -> Swift.String?
  @objc public static func checkVpaAvailability(vpa: Swift.String, account: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> ())
  @objc public static func deRegister(callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func getMerchantChecksum(emailId: Swift.String?, merchId: Swift.String?, merchChanId: Swift.String?, submerchantid: Swift.String?, mcccode: Swift.String?, unqCustId: Swift.String?, timestamp: Swift.String?, mobilenumber: Swift.String?, unqTxnId: Swift.String?, key: Swift.String) -> Swift.String
  @objc public static func profileVpa(vpa: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func createMandate(account: Any?, beneVpa: Any?, mandateInput: Any?, viewController: UIKit.UIViewController, completionHandler: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func modifyMandate(account: Any?, beneVpa: Any?, mandateInput: Any?, viewController: UIKit.UIViewController, completionHandler: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func updateMandate(account: Any?, mandateInput: Any?, newState: Swift.String?, viewController: UIKit.UIViewController, completionHandler: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func executeMandate(mandateInput: Any?, viewController: UIKit.UIViewController, completionHandler: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func authorizeMandate(account: Any?, beneVpa: Any?, mandateInput: Any?, viewController: UIKit.UIViewController, completionHandler: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func authorizeRecurranceMandate(account: Any?, beneVpa: Any?, mandateInput: Any?, viewController: UIKit.UIViewController, completionHandler: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func declineMandate(account: Any?, mandateInput: Any?, viewController: UIKit.UIViewController, completionHandler: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func setUrl(url: Swift.String)
  @objc public static func generateSignedQR(qrString: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func verifySignedQR(qrString: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func getPendingMandates(callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func getRecurranceList(callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func getMandateTransactions(callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func defaultAccount(accountnumber: Swift.String, ifsc: Swift.String, newvpa: Swift.String, oldvpa: Swift.String, defaultvpa: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func checkStatus(check: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func raiseComplaint(check: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func getAddress(address: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func regMapper(mapper: Swift.String, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func reqInternationalQRActivation(account: Swift.String, activation: Swift.String, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func valInternationalQRRequest(account: Swift.String, qrRequest: Swift.String, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc public static func internationalQrStatus(status: Swift.String, viewController: UIKit.UIViewController, callback: @escaping (Any?, Foundation.NSError?) -> Swift.Void)
  @objc deinit
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: OlivePayLibrary.HKDF.Error, b: OlivePayLibrary.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: OlivePayLibrary.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum CryptoSwiftPadding : OlivePayLibrary.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: OlivePayLibrary.CryptoSwiftPadding, b: OlivePayLibrary.CryptoSwiftPadding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : OlivePayLibrary._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [OlivePayLibrary.Bit]
  public func bits() -> Swift.String
}
public struct CFB : OlivePayLibrary.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: OlivePayLibrary.CFB.Error, b: OlivePayLibrary.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: OlivePayLibrary.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping OlivePayLibrary.CipherOperationOnBlock) throws -> OlivePayLibrary.CipherModeWorker
}
extension OlivePayLibrary.AES : OlivePayLibrary.Cryptors {
  final public func makeEncryptor() throws -> OlivePayLibrary.Cryptor & OlivePayLibrary.Updatable
  final public func makeDecryptor() throws -> OlivePayLibrary.Cryptor & OlivePayLibrary.Updatable
}
public enum ReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
  case UnableToGetInitialFlags
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (OlivePayLibrary.Reachability) -> ()
  public typealias NetworkUnreachable = (OlivePayLibrary.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: OlivePayLibrary.Reachability.NetworkStatus, b: OlivePayLibrary.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case none, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: OlivePayLibrary.Reachability.Connection, b: OlivePayLibrary.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: OlivePayLibrary.Reachability.NetworkReachable?
  public var whenUnreachable: OlivePayLibrary.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: OlivePayLibrary.Reachability.Connection {
    get
  }
  public var connection: OlivePayLibrary.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  @objc deinit
}
extension OlivePayLibrary.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct ECB : OlivePayLibrary.BlockMode {
  public let options: OlivePayLibrary.BlockModeOption
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping OlivePayLibrary.CipherOperationOnBlock) throws -> OlivePayLibrary.CipherModeWorker
}
public struct CBC : OlivePayLibrary.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: OlivePayLibrary.CBC.Error, b: OlivePayLibrary.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: OlivePayLibrary.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping OlivePayLibrary.CipherOperationOnBlock) throws -> OlivePayLibrary.CipherModeWorker
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: OlivePayLibrary.CipherError, b: OlivePayLibrary.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension OlivePayLibrary.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class HMAC : OlivePayLibrary.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: OlivePayLibrary.HMAC.Error, b: OlivePayLibrary.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: OlivePayLibrary.HMAC.Variant, b: OlivePayLibrary.HMAC.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: OlivePayLibrary.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension OlivePayLibrary.HMAC {
  convenience public init(key: Swift.String, variant: OlivePayLibrary.HMAC.Variant = .md5) throws
}
@_hasMissingDesignatedInitializers public class BlockDecryptor : OlivePayLibrary.Cryptor, OlivePayLibrary.Updatable {
  public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
public typealias HTTPHeaders = [Swift.String : Swift.String]
extension Swift.String {
  public func decryptBase64ToString(cipher: OlivePayLibrary.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: OlivePayLibrary.Cipher) throws -> Swift.Array<Swift.UInt8>
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: OlivePayLibrary.SHA3.Variant, b: OlivePayLibrary.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: OlivePayLibrary.SHA3.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension OlivePayLibrary.SHA3 : OlivePayLibrary.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
final public class SHA1 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension OlivePayLibrary.SHA1 : OlivePayLibrary.Updatable {
  @discardableResult
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public protocol Key {
  init(data: Foundation.Data) throws
}
@objc public class PublicKey : ObjectiveC.NSObject, OlivePayLibrary.Key {
  required public init(data: Foundation.Data) throws
  convenience public init(base64Encoded base64String: Swift.String) throws
  convenience public init(pemEncoded pemString: Swift.String) throws
  convenience public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  convenience public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  public static func publicKeys(pemEncoded pemString: Swift.String) -> [OlivePayLibrary.PublicKey]
  @objc deinit
}
@objc public class PrivateKey : ObjectiveC.NSObject, OlivePayLibrary.Key {
  required public init(data: Foundation.Data) throws
  convenience public init(base64Encoded base64String: Swift.String) throws
  convenience public init(pemEncoded pemString: Swift.String) throws
  convenience public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  convenience public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  @objc deinit
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: OlivePayLibrary.CCM.Error, b: OlivePayLibrary.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: OlivePayLibrary.BlockModeOption
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping OlivePayLibrary.CipherOperationOnBlock) throws -> OlivePayLibrary.CipherModeWorker
}
extension OlivePayLibrary.AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: OlivePayLibrary.CryptoSwiftPadding = .pkcs7) throws
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: OlivePayLibrary.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: OlivePayLibrary.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: OlivePayLibrary.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: OlivePayLibrary.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: OlivePayLibrary.SHA2.Variant) -> [Element]
  public func sha3(_ variant: OlivePayLibrary.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: OlivePayLibrary.Cipher) throws -> [Element]
  public func decrypt(cipher: OlivePayLibrary.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : OlivePayLibrary.Authenticator
}
@_hasMissingDesignatedInitializers open class CryptLibOne {
  @objc deinit
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: OlivePayLibrary.Rabbit.Error, b: OlivePayLibrary.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension OlivePayLibrary.Rabbit : OlivePayLibrary.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@objc public class Signature : ObjectiveC.NSObject {
  @objc public enum DigestType : Swift.Int {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  final public let data: Foundation.Data
  public init(data: Foundation.Data)
  convenience public init(base64Encoded base64String: Swift.String) throws
  public var base64String: Swift.String {
    get
  }
  @objc deinit
}
final public class GCM : OlivePayLibrary.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: OlivePayLibrary.GCM.Mode, b: OlivePayLibrary.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: OlivePayLibrary.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: OlivePayLibrary.GCM.Error, b: OlivePayLibrary.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: OlivePayLibrary.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: OlivePayLibrary.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping OlivePayLibrary.CipherOperationOnBlock) throws -> OlivePayLibrary.CipherModeWorker
  @objc deinit
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> OlivePayLibrary.Cryptor & OlivePayLibrary.Updatable
  func makeDecryptor() throws -> OlivePayLibrary.Cryptor & OlivePayLibrary.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension OlivePayLibrary.Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension OlivePayLibrary.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: OlivePayLibrary.CryptoSwiftPadding = .pkcs7) throws
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: OlivePayLibrary.ChaCha20.Error, b: OlivePayLibrary.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension OlivePayLibrary.ChaCha20 : OlivePayLibrary.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension OlivePayLibrary.ChaCha20 {
  public struct ChaChaEncryptor : OlivePayLibrary.Cryptor, OlivePayLibrary.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension OlivePayLibrary.ChaCha20 {
  public struct ChaChaDecryptor : OlivePayLibrary.Cryptor, OlivePayLibrary.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension OlivePayLibrary.ChaCha20 : OlivePayLibrary.Cryptors {
  final public func makeEncryptor() -> OlivePayLibrary.Cryptor & OlivePayLibrary.Updatable
  final public func makeDecryptor() -> OlivePayLibrary.Cryptor & OlivePayLibrary.Updatable
}
final public class Poly1305 : OlivePayLibrary.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: OlivePayLibrary.Poly1305.Error, b: OlivePayLibrary.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension OlivePayLibrary.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@_hasMissingDesignatedInitializers @objc public class VerificationResult : ObjectiveC.NSObject {
  final public let isSuccessful: Swift.Bool
  @objc deinit
}
public protocol Message {
  var data: Foundation.Data { get }
  var base64String: Swift.String { get }
  init(data: Foundation.Data)
}
@objc public class EncryptedMessage : ObjectiveC.NSObject, OlivePayLibrary.Message {
  final public let data: Foundation.Data
  public var base64String: Swift.String {
    get
  }
  required public init(data: Foundation.Data)
  convenience public init(base64Encoded base64String: Swift.String) throws
  public func decrypted(with key: OlivePayLibrary.PrivateKey, padding: OlivePayLibrary.Padding) throws -> OlivePayLibrary.ClearMessage
  @objc deinit
}
@objc public class ClearMessage : ObjectiveC.NSObject, OlivePayLibrary.Message {
  final public let data: Foundation.Data
  public var base64String: Swift.String {
    get
  }
  required public init(data: Foundation.Data)
  @nonobjc convenience public init(string: Swift.String, using encoding: Swift.String.Encoding) throws
  @objc convenience public init(string: Swift.String, using rawEncoding: Swift.UInt) throws
  convenience public init(base64Encoded base64String: Swift.String) throws
  public func string(encoding: Swift.String.Encoding) throws -> Swift.String
  public func encrypted(with key: OlivePayLibrary.PublicKey, padding: OlivePayLibrary.Padding) throws -> OlivePayLibrary.EncryptedMessage
  public func signed(with key: OlivePayLibrary.PrivateKey, digestType: OlivePayLibrary.Signature.DigestType) throws -> OlivePayLibrary.Signature
  public func verify(with key: OlivePayLibrary.PublicKey, signature: OlivePayLibrary.Signature, digestType: OlivePayLibrary.Signature.DigestType) throws -> OlivePayLibrary.VerificationResult
  @objc deinit
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = OlivePayLibrary.BlockModeOption
  public typealias Element = OlivePayLibrary.BlockModeOption
  public typealias RawValue = Swift.Int
}
public struct PCBC : OlivePayLibrary.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: OlivePayLibrary.PCBC.Error, b: OlivePayLibrary.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: OlivePayLibrary.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping OlivePayLibrary.CipherOperationOnBlock) throws -> OlivePayLibrary.CipherModeWorker
}
final public class SHA2 {
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: OlivePayLibrary.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: OlivePayLibrary.SHA2.Variant.RawValue)
  }
  public init(variant: OlivePayLibrary.SHA2.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension OlivePayLibrary.SHA2 : OlivePayLibrary.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension OlivePayLibrary.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
public typealias Padding = Security.SecPadding
extension CoreFoundation.CFString : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public static func == (lhs: CoreFoundation.CFString, rhs: CoreFoundation.CFString) -> Swift.Bool
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: OlivePayLibrary.CTR.Error, b: OlivePayLibrary.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: OlivePayLibrary.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping OlivePayLibrary.CipherOperationOnBlock) throws -> OlivePayLibrary.CipherModeWorker
}
extension Swift.String {
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func md5() -> Swift.String
  public func sha1() -> Swift.String
  public func sha224() -> Swift.String
  public func sha256() -> Swift.String
  public func sha384() -> Swift.String
  public func sha512() -> Swift.String
  public func sha3(_ variant: OlivePayLibrary.SHA3.Variant) -> Swift.String
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.String
  public func encrypt(cipher: OlivePayLibrary.Cipher) throws -> Swift.String
  public func encryptToBase64(cipher: OlivePayLibrary.Cipher) throws -> Swift.String?
  public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : OlivePayLibrary.Authenticator
}
extension OlivePayLibrary.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: OlivePayLibrary.PKCS5.PBKDF2.Error, b: OlivePayLibrary.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: OlivePayLibrary.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: OlivePayLibrary.Blowfish.Error, b: OlivePayLibrary.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: OlivePayLibrary.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: OlivePayLibrary.CryptoSwiftPadding) throws
  @objc deinit
}
extension OlivePayLibrary.Blowfish : OlivePayLibrary.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
@available(*, renamed: "Digest")
public typealias Hash = OlivePayLibrary.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: OlivePayLibrary.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: OlivePayLibrary.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: OlivePayLibrary.AES.Error, b: OlivePayLibrary.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: OlivePayLibrary.AES.Variant
  public init(key: Swift.Array<Swift.UInt8>, blockMode: OlivePayLibrary.BlockMode, padding: OlivePayLibrary.CryptoSwiftPadding = .pkcs7) throws
  @objc deinit
}
extension OlivePayLibrary.AES : OlivePayLibrary.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public struct Account {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct AuthorizeMandate {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct RequestMandateTxn {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BeneVpa {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct BillerChargeCalc {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillerChargeCalcResponse {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillerPaymentAdditionalInfo {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillerPaymentAmount {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillerPaymentHistory {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillerRecentHistory {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillerPaymentReq {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillerPayReq {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillerRegEnq {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillerResponse {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillPayMaxAmount {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BillPayRequest {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct BlockedVpa {
  public func getInput() -> Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct DomainUser {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct DTHPrefix {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct ListBeneBlock {
  public func getInput() -> Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct MobilePrefix {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct PayRequest {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class PaymentInput {
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public class Mandate {
  public init()
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public class MandateInput {
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ModifyMandate {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct InitiateMandate {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct RecurrenceAuthorization {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct PayerInitiatedMandate {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct MandateExecute {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct PayeeInitiatedMandate {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct PendingReqVoInput {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct UpdateMandate {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct GetMandate {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct ReqMandateTxn {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct PendingReqVo {
  public func getInput() -> Swift.String
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct RecentBPTHistory {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct TranHistory {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct TxnList {
  public func getInput() -> Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct QueryHistory {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct QueryList {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct QRPay {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct TransactionLimit {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String?
  public init(base64: Swift.String)
}
@_hasMissingDesignatedInitializers open class RegHelper {
  @objc deinit
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension OlivePayLibrary.MD5 : OlivePayLibrary.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension OlivePayLibrary.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: OlivePayLibrary.PKCS5.PBKDF1.Error, b: OlivePayLibrary.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      public static func == (a: OlivePayLibrary.PKCS5.PBKDF1.Variant, b: OlivePayLibrary.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: OlivePayLibrary.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    public func calculate() -> Swift.Array<Swift.UInt8>
  }
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : OlivePayLibrary.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
public protocol CipherModeWorker {
  var cipherOperation: OlivePayLibrary.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : OlivePayLibrary.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : OlivePayLibrary.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : OlivePayLibrary.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : OlivePayLibrary.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : OlivePayLibrary.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : OlivePayLibrary.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
extension OlivePayLibrary.CMAC.Error : Swift.Equatable {}
extension OlivePayLibrary.CMAC.Error : Swift.Hashable {}
extension OlivePayLibrary.OFB.Error : Swift.Equatable {}
extension OlivePayLibrary.OFB.Error : Swift.Hashable {}
extension OlivePayLibrary.HKDF.Error : Swift.Equatable {}
extension OlivePayLibrary.HKDF.Error : Swift.Hashable {}
extension OlivePayLibrary.CryptoSwiftPadding : Swift.Equatable {}
extension OlivePayLibrary.CryptoSwiftPadding : Swift.Hashable {}
extension OlivePayLibrary.CFB.Error : Swift.Equatable {}
extension OlivePayLibrary.CFB.Error : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension OlivePayLibrary.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension OlivePayLibrary.Reachability.NetworkStatus : Swift.Hashable {}
extension OlivePayLibrary.Reachability.Connection : Swift.Equatable {}
extension OlivePayLibrary.Reachability.Connection : Swift.Hashable {}
extension OlivePayLibrary.CBC.Error : Swift.Equatable {}
extension OlivePayLibrary.CBC.Error : Swift.Hashable {}
extension OlivePayLibrary.CipherError : Swift.Equatable {}
extension OlivePayLibrary.CipherError : Swift.Hashable {}
extension OlivePayLibrary.HMAC.Error : Swift.Equatable {}
extension OlivePayLibrary.HMAC.Error : Swift.Hashable {}
extension OlivePayLibrary.HMAC.Variant : Swift.Equatable {}
extension OlivePayLibrary.HMAC.Variant : Swift.Hashable {}
extension OlivePayLibrary.SHA3.Variant : Swift.Equatable {}
extension OlivePayLibrary.SHA3.Variant : Swift.Hashable {}
extension OlivePayLibrary.CCM : OlivePayLibrary.BlockMode {}
extension OlivePayLibrary.CCM.Error : Swift.Equatable {}
extension OlivePayLibrary.CCM.Error : Swift.Hashable {}
extension OlivePayLibrary.Rabbit.Error : Swift.Equatable {}
extension OlivePayLibrary.Rabbit.Error : Swift.Hashable {}
extension OlivePayLibrary.Signature.DigestType : Swift.Equatable {}
extension OlivePayLibrary.Signature.DigestType : Swift.Hashable {}
extension OlivePayLibrary.Signature.DigestType : Swift.RawRepresentable {}
extension OlivePayLibrary.GCM.Mode : Swift.Equatable {}
extension OlivePayLibrary.GCM.Mode : Swift.Hashable {}
extension OlivePayLibrary.GCM.Error : Swift.Equatable {}
extension OlivePayLibrary.GCM.Error : Swift.Hashable {}
extension OlivePayLibrary.ChaCha20.Error : Swift.Equatable {}
extension OlivePayLibrary.ChaCha20.Error : Swift.Hashable {}
extension OlivePayLibrary.Poly1305.Error : Swift.Equatable {}
extension OlivePayLibrary.Poly1305.Error : Swift.Hashable {}
extension OlivePayLibrary.PCBC.Error : Swift.Equatable {}
extension OlivePayLibrary.PCBC.Error : Swift.Hashable {}
extension OlivePayLibrary.SHA2.Variant : Swift.Equatable {}
extension OlivePayLibrary.SHA2.Variant : Swift.Hashable {}
extension OlivePayLibrary.CTR : OlivePayLibrary.BlockMode {}
extension OlivePayLibrary.CTR.Error : Swift.Equatable {}
extension OlivePayLibrary.CTR.Error : Swift.Hashable {}
extension OlivePayLibrary.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension OlivePayLibrary.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension OlivePayLibrary.Blowfish.Error : Swift.Equatable {}
extension OlivePayLibrary.Blowfish.Error : Swift.Hashable {}
extension OlivePayLibrary.Bit : Swift.Equatable {}
extension OlivePayLibrary.Bit : Swift.Hashable {}
extension OlivePayLibrary.Bit : Swift.RawRepresentable {}
extension OlivePayLibrary.AES.Error : Swift.Equatable {}
extension OlivePayLibrary.AES.Error : Swift.Hashable {}
extension OlivePayLibrary.AES.Variant : Swift.Equatable {}
extension OlivePayLibrary.AES.Variant : Swift.Hashable {}
extension OlivePayLibrary.AES.Variant : Swift.RawRepresentable {}
extension OlivePayLibrary.Account : Swift.Decodable {}
extension OlivePayLibrary.Account : Swift.Encodable {}
extension OlivePayLibrary.AuthorizeMandate : Swift.Decodable {}
extension OlivePayLibrary.AuthorizeMandate : Swift.Encodable {}
extension OlivePayLibrary.RequestMandateTxn : Swift.Decodable {}
extension OlivePayLibrary.RequestMandateTxn : Swift.Encodable {}
extension OlivePayLibrary.BeneVpa : Swift.Decodable {}
extension OlivePayLibrary.BeneVpa : Swift.Encodable {}
extension OlivePayLibrary.BillerChargeCalc : Swift.Decodable {}
extension OlivePayLibrary.BillerChargeCalc : Swift.Encodable {}
extension OlivePayLibrary.BillerChargeCalcResponse : Swift.Decodable {}
extension OlivePayLibrary.BillerChargeCalcResponse : Swift.Encodable {}
extension OlivePayLibrary.BillerPaymentAdditionalInfo : Swift.Decodable {}
extension OlivePayLibrary.BillerPaymentAdditionalInfo : Swift.Encodable {}
extension OlivePayLibrary.BillerPaymentAmount : Swift.Decodable {}
extension OlivePayLibrary.BillerPaymentAmount : Swift.Encodable {}
extension OlivePayLibrary.BillerPaymentHistory : Swift.Decodable {}
extension OlivePayLibrary.BillerPaymentHistory : Swift.Encodable {}
extension OlivePayLibrary.BillerRecentHistory : Swift.Decodable {}
extension OlivePayLibrary.BillerRecentHistory : Swift.Encodable {}
extension OlivePayLibrary.BillerPaymentReq : Swift.Decodable {}
extension OlivePayLibrary.BillerPaymentReq : Swift.Encodable {}
extension OlivePayLibrary.BillerPayReq : Swift.Decodable {}
extension OlivePayLibrary.BillerPayReq : Swift.Encodable {}
extension OlivePayLibrary.BillerRegEnq : Swift.Decodable {}
extension OlivePayLibrary.BillerRegEnq : Swift.Encodable {}
extension OlivePayLibrary.BillerResponse : Swift.Decodable {}
extension OlivePayLibrary.BillerResponse : Swift.Encodable {}
extension OlivePayLibrary.BillPayMaxAmount : Swift.Decodable {}
extension OlivePayLibrary.BillPayMaxAmount : Swift.Encodable {}
extension OlivePayLibrary.BillPayRequest : Swift.Decodable {}
extension OlivePayLibrary.BillPayRequest : Swift.Encodable {}
extension OlivePayLibrary.BlockedVpa : Swift.Decodable {}
extension OlivePayLibrary.BlockedVpa : Swift.Encodable {}
extension OlivePayLibrary.DomainUser : Swift.Decodable {}
extension OlivePayLibrary.DomainUser : Swift.Encodable {}
extension OlivePayLibrary.DTHPrefix : Swift.Decodable {}
extension OlivePayLibrary.DTHPrefix : Swift.Encodable {}
extension OlivePayLibrary.ListBeneBlock : Swift.Decodable {}
extension OlivePayLibrary.ListBeneBlock : Swift.Encodable {}
extension OlivePayLibrary.MobilePrefix : Swift.Decodable {}
extension OlivePayLibrary.MobilePrefix : Swift.Encodable {}
extension OlivePayLibrary.PayRequest : Swift.Decodable {}
extension OlivePayLibrary.PayRequest : Swift.Encodable {}
extension OlivePayLibrary.PaymentInput : Swift.Decodable {}
extension OlivePayLibrary.PaymentInput : Swift.Encodable {}
extension OlivePayLibrary.Mandate : Swift.Decodable {}
extension OlivePayLibrary.Mandate : Swift.Encodable {}
extension OlivePayLibrary.MandateInput : Swift.Decodable {}
extension OlivePayLibrary.MandateInput : Swift.Encodable {}
extension OlivePayLibrary.ModifyMandate : Swift.Decodable {}
extension OlivePayLibrary.ModifyMandate : Swift.Encodable {}
extension OlivePayLibrary.InitiateMandate : Swift.Decodable {}
extension OlivePayLibrary.InitiateMandate : Swift.Encodable {}
extension OlivePayLibrary.RecurrenceAuthorization : Swift.Decodable {}
extension OlivePayLibrary.RecurrenceAuthorization : Swift.Encodable {}
extension OlivePayLibrary.PayerInitiatedMandate : Swift.Decodable {}
extension OlivePayLibrary.PayerInitiatedMandate : Swift.Encodable {}
extension OlivePayLibrary.MandateExecute : Swift.Decodable {}
extension OlivePayLibrary.MandateExecute : Swift.Encodable {}
extension OlivePayLibrary.PayeeInitiatedMandate : Swift.Decodable {}
extension OlivePayLibrary.PayeeInitiatedMandate : Swift.Encodable {}
extension OlivePayLibrary.PendingReqVoInput : Swift.Decodable {}
extension OlivePayLibrary.PendingReqVoInput : Swift.Encodable {}
extension OlivePayLibrary.UpdateMandate : Swift.Decodable {}
extension OlivePayLibrary.UpdateMandate : Swift.Encodable {}
extension OlivePayLibrary.GetMandate : Swift.Decodable {}
extension OlivePayLibrary.GetMandate : Swift.Encodable {}
extension OlivePayLibrary.ReqMandateTxn : Swift.Decodable {}
extension OlivePayLibrary.ReqMandateTxn : Swift.Encodable {}
extension OlivePayLibrary.PendingReqVo : Swift.Decodable {}
extension OlivePayLibrary.PendingReqVo : Swift.Encodable {}
extension OlivePayLibrary.RecentBPTHistory : Swift.Decodable {}
extension OlivePayLibrary.RecentBPTHistory : Swift.Encodable {}
extension OlivePayLibrary.TranHistory : Swift.Decodable {}
extension OlivePayLibrary.TranHistory : Swift.Encodable {}
extension OlivePayLibrary.TxnList : Swift.Decodable {}
extension OlivePayLibrary.TxnList : Swift.Encodable {}
extension OlivePayLibrary.QueryHistory : Swift.Decodable {}
extension OlivePayLibrary.QueryHistory : Swift.Encodable {}
extension OlivePayLibrary.QueryList : Swift.Decodable {}
extension OlivePayLibrary.QueryList : Swift.Encodable {}
extension OlivePayLibrary.QRPay : Swift.Decodable {}
extension OlivePayLibrary.QRPay : Swift.Encodable {}
extension OlivePayLibrary.TransactionLimit : Swift.Decodable {}
extension OlivePayLibrary.TransactionLimit : Swift.Encodable {}
extension OlivePayLibrary.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension OlivePayLibrary.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension OlivePayLibrary.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension OlivePayLibrary.PKCS5.PBKDF1.Variant : Swift.Hashable {}
